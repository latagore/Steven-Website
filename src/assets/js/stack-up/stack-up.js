// Generated by CoffeeScript 1.10.0
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.StackUp = (function() {
    StackUp.prototype.containerElement = void 0;

    StackUp.prototype.itemElements = void 0;

    StackUp.prototype.containerHeight = 0;

    StackUp.prototype.containerWidth = 0;

    StackUp.prototype.items = [];

    StackUp.prototype.numberOfColumns = 0;

    StackUp.prototype.boundary = {
      height: 0,
      width: 0
    };

    StackUp.prototype.config = {
      containerSelector: void 0,
      itemsSelector: void 0,
      boundary: window,
      columnWidth: 320,
      gutter: 18,
      isFluid: false,
      layout: 'ordinal',
      numberOfColumns: 3,
      resizeDebounceDelay: 350,
      moveItem: function(item, left, top, callback) {
        item.style.left = left + 'px';
        item.style.top = top + 'px';
        return callback();
      },
      scaleContainer: function(container, width, height, callback) {
        container.style.height = height + 'px';
        container.style.width = width + 'px';
        return callback();
      }
    };

    function StackUp(properties) {
      this.resizeHandler = bind(this.resizeHandler, this);
      this.resizeComplete = bind(this.resizeComplete, this);
      var property, value;
      for (property in properties) {
        value = properties[property];
        this.config[property] = value;
      }
    }

    StackUp.prototype.initialize = function() {
      window.addEventListener('resize', this.resizeHandler);
      this.boundaryUpdate();
      this.updateSelectors();
      this.populateItems();
      this.updateNumberOfColumns();
      this.applyLayout();
      return this.draw();
    };

    StackUp.prototype.boundaryUpdate = function() {
      var horizontalPaddings, style, verticalPaddings;
      if (this.config.boundary !== window) {
        style = this.config.boundary.currentStyle || window.getComputedStyle(this.config.boundary);
        horizontalPaddings = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
        verticalPaddings = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
        this.boundary.height = this.config.boundary.offsetHeight - verticalPaddings;
        return this.boundary.width = this.config.boundary.offsetWidth - horizontalPaddings;
      } else {
        this.boundary.height = window.innerHeight;
        return this.boundary.width = window.innerWidth;
      }
    };

    StackUp.prototype.resizeDebounceTimeout = void 0;

    StackUp.prototype.resizeDebounce = function(fn, delay) {
      clearTimeout(this.resizeDebounceTimeout);
      return this.resizeDebounceTimeout = window.setTimeout(fn, delay);
    };

    StackUp.prototype.resizeComplete = function() {
      if (this.calculateNumberOfColumns() !== this.numberOfColumns && this.config.isFluid) {
        return this.restack();
      }
    };

    StackUp.prototype.resizeHandler = function() {
      this.boundaryUpdate();
      return this.resizeDebounce(this.resizeComplete, this.config.resizeDebounceDelay);
    };

    StackUp.prototype.updateSelectors = function() {
      this.containerElement = document.querySelector(this.config.containerSelector);
      return this.itemElements = document.querySelectorAll(this.config.containerSelector + " > " + this.config.itemsSelector);
    };

    StackUp.prototype.appendItem = function(item) {
      item.style.width = this.config.columnWidth + "px";
      return this.items.push([item, item.offsetHeight, 0, 0]);
    };

    StackUp.prototype.populateItems = function() {
      var index, item, j, len, ref, results;
      this.items = [];
      ref = this.itemElements;
      results = [];
      for (index = j = 0, len = ref.length; j < len; index = ++j) {
        item = ref[index];
        results.push(this.appendItem(item));
      }
      return results;
    };

    StackUp.prototype.calculateNumberOfColumns = function() {
      var numberOfColumns;
      if (this.config.isFluid) {
        numberOfColumns = Math.floor((this.boundary.width - this.config.gutter) / (this.config.columnWidth + this.config.gutter));
      } else {
        numberOfColumns = this.config.numberOfColumns;
      }
      if (numberOfColumns > this.items.length) {
        numberOfColumns = this.items.length;
      }
      if (this.items.length && numberOfColumns <= 0) {
        numberOfColumns = 1;
      }
      return numberOfColumns;
    };

    StackUp.prototype.updateNumberOfColumns = function() {
      return this.numberOfColumns = this.calculateNumberOfColumns();
    };

    StackUp.prototype.draw = function() {
      var height, width;
      this.containerWidth = (this.config.columnWidth + this.config.gutter) * this.numberOfColumns;
      height = this.containerHeight + this.config.gutter;
      width = this.containerWidth + this.config.gutter;
      return this.config.scaleContainer(this.containerElement, width, height, (function(_this) {
        return function() {
          var callback, index, item, j, len, ref, results;
          callback = function() {};
          ref = _this.items;
          results = [];
          for (index = j = 0, len = ref.length; j < len; index = ++j) {
            item = ref[index];
            results.push(_this.config.moveItem(item[0], item[2], item[3], callback));
          }
          return results;
        };
      })(this));
    };

    StackUp.prototype.layout = {
      columnPointer: 0,
      ordinal: {
        stack: [],
        setup: function() {
          var i;
          return this.stack = (function() {
            var j, ref, ref1, results;
            results = [];
            for (i = j = 0, ref = this.context.numberOfColumns - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
              results.push((ref1 = 0, i = ref1[0], ref1));
            }
            return results;
          }).call(this);
        },
        plot: function(itemIndex) {
          var c;
          c = this.context;
          c.items[itemIndex][2] = c.config.gutter + (c.config.columnWidth + c.config.gutter) * c.layout.columnPointer;
          c.items[itemIndex][3] = c.config.gutter + this.stack[c.layout.columnPointer];
          this.stack[c.layout.columnPointer] += c.items[itemIndex][1] + c.config.gutter;
          if (this.stack[c.layout.columnPointer] > c.containerHeight) {
            c.containerHeight = this.stack[c.layout.columnPointer];
          }
          c.layout.columnPointer++;
          if (c.layout.columnPointer >= c.numberOfColumns) {
            return c.layout.columnPointer = 0;
          }
        },
        loop: function() {
          var i, j, ref, results;
          results = [];
          for (i = j = 0, ref = this.context.items.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
            results.push(this.plot(i));
          }
          return results;
        }
      },
      optimized: {
        stack: [],
        setup: function() {
          var i;
          return this.stack = (function() {
            var j, ref, ref1, results;
            results = [];
            for (i = j = 0, ref = this.context.numberOfColumns - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
              results.push((ref1 = [i, 0], i = ref1[0], ref1));
            }
            return results;
          }).call(this);
        },
        plot: function(itemIndex) {
          var c;
          c = this.context;
          c.items[itemIndex][2] = c.config.gutter + (c.config.columnWidth + c.config.gutter) * this.stack[0][0];
          c.items[itemIndex][3] = c.config.gutter + this.stack[0][1];
          this.stack[0][1] += c.items[itemIndex][1] + c.config.gutter;
          if (this.stack[0][1] > c.containerHeight) {
            c.containerHeight = this.stack[0][1];
          }
          this.stack.sort((function(a, b) {
            return a[1] - b[1];
          }));
          c.layout.columnPointer++;
          if (c.layout.columnPointer >= c.numberOfColumns) {
            return c.layout.columnPointer = 0;
          }
        },
        loop: function() {
          var i, j, ref, results;
          results = [];
          for (i = j = 0, ref = this.context.items.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
            results.push(this.plot(i));
          }
          return results;
        }
      }
    };

    StackUp.prototype.applyLayout = function() {
      this.layout[this.config.layout].context = this;
      this.layout[this.config.layout].setup();
      if (this.items.length) {
        return this.layout[this.config.layout].loop();
      }
    };

    StackUp.prototype.resetLayout = function() {
      this.containerHeight = 0;
      return this.layout.columnPointer = 0;
    };

    StackUp.prototype.reset = function() {
      this.containerWidth = 0;
      this.containerHeight = 0;
      this.items = [];
      this.updateSelectors();
      this.populateItems();
      this.resetLayout();
      this.restack();
    };

    StackUp.prototype.append = function(item, callback) {
      var itemIndex;
      itemIndex = this.items.length;
      this.appendItem(item);
      if (this.calculateNumberOfColumns() === this.numberOfColumns) {
        this.layoutType[stackgrid.config.layout].plot(itemIndex);
        return this.draw();
      } else {
        return this.restack();
      }
    };

    StackUp.prototype.restack = function() {
      this.updateNumberOfColumns();
      this.resetLayout();
      this.applyLayout();
      return this.draw();
    };

    return StackUp;

  })();

}).call(this);
